<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üê±üí• apoCATlypse Meow - APOCAT</title>
    <meta name="description" content="Epic zombie apocalypse game where APOCAT saves the world with paw swipes! Earn APOCAT tokens for high scores and achievements.">
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: white;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        
        h1 {
            text-align: center;
            color: #ff6b6b;
            text-shadow: 0 0 10px rgba(255, 107, 107, 0.5);
            margin-bottom: 20px;
        }
        
        .game-container {
            position: relative;
            display: inline-block;
        }
        
        #gameCanvas {
            border: 2px solid #667eea;
            border-radius: 10px;
            cursor: pointer;
            background: #000;
        }
        
        .info {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            max-width: 800px;
        }

        .web3-status {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #ff6b6b;
            font-size: 12px;
        }

        .connect-wallet-btn {
            background: #ff6b6b;
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            margin-top: 5px;
        }

        .connect-wallet-btn:hover {
            background: #ff5555;
        }
    </style>
</head>
<body>
    <h1>üê±üí• apoCATlypse Meow - APOCAT</h1>
    
    <!-- Web3 Status -->
    <div class="web3-status" id="web3Status">
        <div>üåê Web3 Status: <span id="connectionStatus">Checking...</span></div>
        <div id="walletInfo" style="margin-top: 5px;"></div>
        <button class="connect-wallet-btn" id="connectWalletBtn" onclick="connectWallet()">
            Connect Wallet
        </button>
    </div>

    <div class="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
    </div>
    


    <!-- Chat System -->
    <div id="chatContainer" style="
        width: 800px;
        height: 200px;
        background: rgba(0, 0, 0, 0.8);
        border: 2px solid #ff6600;
        border-radius: 10px;
        margin-top: 20px;
        padding: 10px;
        display: flex;
        flex-direction: column;
    ">
        <div style="color: #ff6600; font-weight: bold; margin-bottom: 10px; text-align: center;">
            üó®Ô∏è APOCAT Community Chat üó®Ô∏è
        </div>
        <div id="chatMessages" style="
            flex: 1;
            overflow-y: auto;
            color: #fff;
            font-family: Arial, sans-serif;
            font-size: 14px;
            margin-bottom: 10px;
            padding: 5px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
        "></div>
        <div style="display: flex; gap: 10px;">
            <input type="text" id="chatInput" placeholder="Type your message..." style="
                flex: 1;
                padding: 8px;
                border: 1px solid #ff6600;
                border-radius: 5px;
                background: rgba(0, 0, 0, 0.7);
                color: #fff;
                font-size: 14px;
            " maxlength="100">
            <button id="chatSend" style="
                padding: 8px 16px;
                background: #ff6600;
                color: #fff;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-weight: bold;
            ">Send</button>
        </div>
    </div>

    <!-- Web3 Integration -->
    <script>
        // Web3 Detection and Connection
        let web3Provider = null;
        let userAccount = null;
        let isWeb3Enabled = false;

        async function detectWeb3() {
            const statusEl = document.getElementById('connectionStatus');
            const walletInfoEl = document.getElementById('walletInfo');
            const connectBtn = document.getElementById('connectWalletBtn');

            if (typeof window.ethereum !== 'undefined') {
                statusEl.textContent = 'MetaMask Detected';
                statusEl.style.color = '#00ff88';
                web3Provider = window.ethereum;
                isWeb3Enabled = true;
                
                try {
                    const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                    if (accounts.length > 0) {
                        userAccount = accounts[0];
                        updateWalletDisplay();
                    }
                } catch (error) {
                    console.log('Not connected yet');
                }
            } else {
                statusEl.textContent = 'No Web3 Wallet';
                statusEl.style.color = '#ff6b6b';
                walletInfoEl.innerHTML = '<div style="color: #ffaa44;">Install MetaMask to earn tokens!</div>';
                connectBtn.style.display = 'none';
            }
        }

        async function connectWallet() {
            if (!isWeb3Enabled) {
                alert('Please install MetaMask to connect your wallet!');
                return;
            }

            try {
                const accounts = await window.ethereum.request({ 
                    method: 'eth_requestAccounts' 
                });
                
                if (accounts.length > 0) {
                    userAccount = accounts[0];
                    updateWalletDisplay();
                    
                    if (typeof walletAddress !== 'undefined') {
                        walletAddress = userAccount;
                    }
                    
                    console.log('üéâ Wallet connected:', userAccount);
                }
            } catch (error) {
                console.error('Failed to connect wallet:', error);
                alert('Failed to connect wallet. Please try again.');
            }
        }

        function updateWalletDisplay() {
            const walletInfoEl = document.getElementById('walletInfo');
            const connectBtn = document.getElementById('connectWalletBtn');
            
            if (userAccount) {
                walletInfoEl.innerHTML = `
                    <div style="color: #00ff88;">‚úÖ Connected</div>
                    <div style="color: #ccc; font-size: 10px;">${userAccount.slice(0, 6)}...${userAccount.slice(-4)}</div>
                `;
                connectBtn.textContent = 'Disconnect';
                connectBtn.onclick = disconnectWallet;
            }
        }

        function disconnectWallet() {
            userAccount = null;
            const walletInfoEl = document.getElementById('walletInfo');
            const connectBtn = document.getElementById('connectWalletBtn');
            
            walletInfoEl.innerHTML = '';
            connectBtn.textContent = 'Connect Wallet';
            connectBtn.onclick = connectWallet;
            
            if (typeof walletAddress !== 'undefined') {
                walletAddress = null;
            }
            
            console.log('üëã Wallet disconnected');
        }

        // Initialize Web3 detection
        window.addEventListener('load', detectWeb3);

        // Listen for account changes
        if (typeof window.ethereum !== 'undefined') {
            window.ethereum.on('accountsChanged', (accounts) => {
                if (accounts.length > 0) {
                    userAccount = accounts[0];
                    updateWalletDisplay();
                    if (typeof walletAddress !== 'undefined') {
                        walletAddress = userAccount;
                    }
                } else {
                    disconnectWallet();
                }
            });
        }
    </script>

    <!-- Complete Game Script -->
    <script>
        // Game initialization
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameInfo = document.getElementById('gameInfo');

        // Sound system
        const sounds = {
            backgroundMusic: null,
            pawHit: [],
            pawMiss: [],
            enemyDeath: [],
            playerDeath: null,
            bossSpawn: null
        };

        function initSounds() {
            // Create multiple instances for overlapping sounds
            for (let i = 0; i < 5; i++) {
                sounds.pawHit[i] = createSoundFromFrequency(400, 0.1, 'square'); // Cat paw swipe
                sounds.pawMiss[i] = createSoundFromFrequency(200, 0.15, 'sine'); // Miss sound
                sounds.enemyDeath[i] = createSoundFromFrequency(150, 0.3, 'sawtooth'); // Enemy death
            }
            sounds.playerDeath = createSoundFromFrequency(100, 1.0, 'triangle'); // Player death
            sounds.bossSpawn = createSoundFromFrequency(80, 2.0, 'square'); // Boss spawn

            // Background music - apocalyptic ambient
            sounds.backgroundMusic = createApocalypticMusic();
        }

        let audioContext = null;

        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            return audioContext;
        }

        function createSoundFromFrequency(frequency, duration, waveType = 'sine') {
            return function() {
                try {
                    const ctx = initAudioContext();
                    if (ctx.state === 'suspended') {
                        ctx.resume();
                    }

                    const oscillator = ctx.createOscillator();
                    const gainNode = ctx.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(ctx.destination);

                    oscillator.frequency.setValueAtTime(frequency, ctx.currentTime);
                    oscillator.type = waveType;

                    // Much quieter to prevent buzzing
                    gainNode.gain.setValueAtTime(0.02, ctx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);

                    oscillator.start(ctx.currentTime);
                    oscillator.stop(ctx.currentTime + duration);
                } catch (e) {
                    console.log('Sound disabled');
                }
            };
        }

        function createApocalypticMusic() {
            let isPlaying = false;
            let currentOscillators = [];

            return {
                start: function() {
                    if (isPlaying) return;
                    isPlaying = true;
                    this.playLoop();
                },
                stop: function() {
                    isPlaying = false;
                    // Stop all current oscillators
                    currentOscillators.forEach(osc => {
                        try { osc.stop(); } catch(e) {}
                    });
                    currentOscillators = [];
                },
                playLoop: function() {
                    if (!isPlaying) return;

                    try {
                        const ctx = initAudioContext();
                        if (ctx.state === 'suspended') {
                            ctx.resume();
                        }

                        // Create very subtle ambient tones
                        const oscillator1 = ctx.createOscillator();
                        const oscillator2 = ctx.createOscillator();
                        const gainNode = ctx.createGain();
                        const filterNode = ctx.createBiquadFilter();

                        // Add low-pass filter to make it more mellow
                        oscillator1.connect(filterNode);
                        oscillator2.connect(filterNode);
                        filterNode.connect(gainNode);
                        gainNode.connect(ctx.destination);

                        // Filter settings for chill sound
                        filterNode.type = 'lowpass';
                        filterNode.frequency.setValueAtTime(200, ctx.currentTime);
                        filterNode.Q.setValueAtTime(1, ctx.currentTime);

                        // Very low, chill frequencies
                        oscillator1.frequency.setValueAtTime(65.4, ctx.currentTime); // C2
                        oscillator1.type = 'sine'; // Smoother than sawtooth

                        oscillator2.frequency.setValueAtTime(98, ctx.currentTime); // G2
                        oscillator2.type = 'triangle';

                        // Very quiet volume
                        gainNode.gain.setValueAtTime(0.008, ctx.currentTime);

                        oscillator1.start(ctx.currentTime);
                        oscillator2.start(ctx.currentTime);
                        oscillator1.stop(ctx.currentTime + 12);
                        oscillator2.stop(ctx.currentTime + 12);

                        currentOscillators = [oscillator1, oscillator2];

                        // Loop every 12 seconds with slight variation
                        setTimeout(() => this.playLoop(), 12000 + Math.random() * 2000);
                    } catch (e) {
                        console.log('Background music disabled');
                    }
                }
            };
        }

        function playSound(soundArray) {
            if (!soundArray) return;

            if (Array.isArray(soundArray)) {
                // Find available sound instance
                const sound = soundArray[Math.floor(Math.random() * soundArray.length)];
                sound();
            } else {
                soundArray();
            }
        }

        // Initialize sounds when page loads
        let soundsInitialized = false;
        function initSoundsOnFirstClick() {
            if (!soundsInitialized) {
                initSounds();
                sounds.backgroundMusic.start();
                soundsInitialized = true;
            }
        }

        // Chat system
        const chatMessages = document.getElementById('chatMessages');
        const chatInput = document.getElementById('chatInput');
        const chatSend = document.getElementById('chatSend');
        let chatHistory = [];

        function addChatMessage(username, message, isSystem = false) {
            const timestamp = new Date().toLocaleTimeString();
            const messageDiv = document.createElement('div');
            messageDiv.style.marginBottom = '5px';
            messageDiv.style.wordWrap = 'break-word';

            if (isSystem) {
                messageDiv.style.color = '#ffaa44';
                messageDiv.innerHTML = `<span style="color: #666;">[${timestamp}]</span> <strong>ü§ñ SYSTEM:</strong> ${message}`;
            } else {
                messageDiv.innerHTML = `<span style="color: #666;">[${timestamp}]</span> <span style="color: #ff6600;">${username}:</span> ${message}`;
            }

            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;

            // Keep only last 50 messages
            while (chatMessages.children.length > 50) {
                chatMessages.removeChild(chatMessages.firstChild);
            }
        }

        function sendChatMessage() {
            const message = chatInput.value.trim();
            if (message && message.length > 0) {
                const username = walletAddress ? `${walletAddress.slice(0, 6)}...${walletAddress.slice(-4)}` : 'Anonymous';
                addChatMessage(username, message);
                chatInput.value = '';

                // Simulate other players (for demo)
                if (Math.random() < 0.3) {
                    setTimeout(() => {
                        const responses = [
                            "Nice score! üî•",
                            "APOCAT to the moon! üöÄ",
                            "Just got rekt by the boss üòÖ",
                            "This game is addictive!",
                            "Anyone else farming tokens? üí∞",
                            "GG everyone! üéÆ"
                        ];
                        const randomUser = `0x${Math.random().toString(16).substr(2, 4)}...${Math.random().toString(16).substr(2, 4)}`;
                        addChatMessage(randomUser, responses[Math.floor(Math.random() * responses.length)]);
                    }, 1000 + Math.random() * 3000);
                }
            }
        }

        chatSend.addEventListener('click', sendChatMessage);
        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendChatMessage();
            }
        });

        // Add welcome message
        addChatMessage('', 'Welcome to APOCAT! Share your scores and strategies! üê±‚öîÔ∏è', true);

        // Game state
        let gameState = 'menu';
        let assetsLoaded = true; // No external assets needed

        // Game variables
        let score = 0;
        let round = 1;
        let roundTimer = 30;
        let roundStartTime = 0;
        let zombies = [];
        let catFood = [];
        let particles = [];
        let pawSwipes = [];
        let mouse = { x: 400, y: 300 };
        let zombieSpawnTimer = 0;
        let foodSpawnTimer = 0;
        let foodSpawnInterval = 8000; // Food spawns every 8 seconds (less frequent)
        let zombiesSurvived = 0;
        let maxSurvivors = 3;
        let baseLives = 3;
        let extraLives = 0;
        let zombiesKilled = 0;
        let totalPaws = 0;
        let hits = 0;
        let walletAddress = null;

        // Gameplay enhancement variables
        let comboCount = 0;
        let comboTimer = 0;
        let lastHitTime = 0;
        let perfectHits = 0;
        let missStreak = 0;

        // Enhanced Stamina system (much harder)
        let stamina = 60;
        let maxStamina = 60;
        let staminaRegenRate = 3; // Much slower regen
        let staminaCost = 20; // Higher cost per click
        let staminaBoostActive = false;
        let staminaBoostTimer = 0;

        // Boss system
        let currentBoss = null;
        let bossSpawned = false;

        // Animation system
        let animations = [];

        // Upgrade system
        let coins = 0; // Currency for upgrades
        let upgrades = {
            biggerPaw: { level: 0, maxLevel: 5, cost: 50, name: "Bigger Paw", description: "Larger hit radius" },
            strongerPaw: { level: 0, maxLevel: 5, cost: 75, name: "Stronger Paw", description: "More damage per hit" },
            moreEnergy: { level: 0, maxLevel: 5, cost: 100, name: "More Energy", description: "Increased max stamina" },
            energyRegen: { level: 0, maxLevel: 5, cost: 125, name: "Energy Regen", description: "Faster stamina recovery" }
        };

        // Apocalyptic wasteland obstacles
        let collisionZones = [
            {
                x: 120, y: 400, width: 100, height: 140, type: 'ruins',
                occlusionHeight: 90, shadowOffset: 20
            },
            {
                x: 380, y: 360, width: 80, height: 160, type: 'debris',
                occlusionHeight: 110, shadowOffset: 25
            },
            {
                x: 620, y: 420, width: 110, height: 120, type: 'wreckage',
                occlusionHeight: 80, shadowOffset: 18
            }
        ];

        // Unified APOCAT color palette
        const APOCAT_COLORS = {
            skyDark: '#2c1810',
            skyMid: '#4a2c2a',
            skyLight: '#1a1a2e',
            ground: '#0f0f23',
            buildingDark: '#2d2d2d',
            buildingMid: '#3d3d3d',
            buildingLight: '#4a4a4a',
            windowOff: '#1a1a1a',
            windowOn: '#ffaa44',
            zombieGreen: '#4a5d23',
            zombieGreenDark: '#3d4f1c',
            zombiePurple: '#2d1b69',
            zombiePurpleDark: '#1a0f3d',
            zombieRed: '#8b0000',
            zombieRedDark: '#600000',
            catOrange: '#ff6b6b',
            energyGreen: '#00ff88',
            warningYellow: '#ffaa44',
            glowBlue: '#667eea'
        };

        // Enhanced reward tracking system
        const rewardSystem = {
            pendingRewards: JSON.parse(localStorage.getItem('apocatPendingRewards') || '[]'),
            claimedRewards: JSON.parse(localStorage.getItem('apocatClaimedRewards') || '[]'),
            playerProgress: JSON.parse(localStorage.getItem('apocatProgress') || '{}'),

            addReward(type, amount, description) {
                const reward = {
                    id: Date.now() + Math.random(),
                    type: type,
                    amount: amount,
                    description: description,
                    walletAddress: walletAddress || 'Anonymous',
                    timestamp: Date.now(),
                    date: new Date().toLocaleDateString()
                };

                this.pendingRewards.push(reward);
                localStorage.setItem('apocatPendingRewards', JSON.stringify(this.pendingRewards));

                // Send to distribution bot if wallet connected
                if (walletAddress && walletAddress !== 'Anonymous') {
                    this.sendToDistributionBot(walletAddress, type, amount, description);
                }

                // Add chat notification
                if (typeof addChatMessage === 'function') {
                    addChatMessage('', `ü™ô ${walletAddress ? walletAddress.slice(0, 6) + '...' : 'Anonymous'} earned ${amount} APOCAT! (${description})`, true);
                }

                console.log(`ü™ô Reward earned: ${amount} APOCAT for ${description}`);
            },

            async sendToDistributionBot(walletAddress, rewardType, amount, description) {
                try {
                    const response = await fetch('http://localhost:3000/api/reward', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            walletAddress: walletAddress,
                            rewardType: rewardType,
                            amount: amount,
                            description: description
                        })
                    });

                    if (response.ok) {
                        const result = await response.json();
                        console.log('ü§ñ Bot notification sent:', result.message);
                    } else {
                        console.log('‚ö†Ô∏è Bot offline - rewards stored locally');
                    }
                } catch (error) {
                    console.log('‚ö†Ô∏è Bot connection failed - rewards stored locally');
                }
            },

            getTotalPending() {
                return this.pendingRewards.reduce((total, reward) => total + parseFloat(reward.amount), 0);
            },

            getTotalClaimed() {
                return this.claimedRewards.reduce((total, reward) => total + parseFloat(reward.amount), 0);
            },

            checkNewHighScore(score) {
                const currentWallet = walletAddress || 'Anonymous';
                const playerBest = this.playerProgress[currentWallet]?.bestScore || 0;

                if (score > playerBest) {
                    this.playerProgress[currentWallet] = {
                        ...this.playerProgress[currentWallet],
                        bestScore: score
                    };
                    localStorage.setItem('apocatProgress', JSON.stringify(this.playerProgress));

                    this.addReward('high_score', '1', 'New High Score');
                    return true;
                }
                return false;
            },

            checkNewRoundRecord(round) {
                const currentWallet = walletAddress || 'Anonymous';
                const playerBest = this.playerProgress[currentWallet]?.bestRound || 0;

                if (round > playerBest) {
                    this.playerProgress[currentWallet] = {
                        ...this.playerProgress[currentWallet],
                        bestRound: round
                    };
                    localStorage.setItem('apocatProgress', JSON.stringify(this.playerProgress));

                    this.addReward('new_round', '0.01', `Reached Round ${round} for first time`);
                    return true;
                }
                return false;
            },

            awardRoundCompletion() {
                this.addReward('round_complete', '0.001', 'Round completed');
            },

            awardBossDefeat() {
                this.addReward('boss_defeat', '0.005', 'Boss defeated');
            },

            awardPerfectRound() {
                this.addReward('perfect_round', '0.002', 'Perfect round (no misses)');
            },

            async collectRewards(walletAddress, totalAmount) {
                try {
                    addChatMessage('', `üîÑ Processing ${totalAmount.toFixed(3)} APOCAT collection for ${walletAddress.slice(0, 6)}...`, true);

                    // Check bot status first
                    const botStatus = await this.checkBotStatus();

                    if (botStatus.online) {
                        // Bot is online - rewards will be automatically distributed
                        addChatMessage('', `ü§ñ Distribution bot is processing your rewards automatically!`, true);
                        addChatMessage('', `üí∞ ${totalAmount.toFixed(3)} APOCAT will be sent to your wallet shortly`, true);

                        // Move to claimed (bot will handle actual distribution)
                        this.claimedRewards.push(...this.pendingRewards);
                        this.pendingRewards = [];
                        localStorage.setItem('apocatClaimedRewards', JSON.stringify(this.claimedRewards));
                        localStorage.setItem('apocatPendingRewards', JSON.stringify(this.pendingRewards));

                        console.log(`ü§ñ Bot processing ${totalAmount.toFixed(3)} APOCAT for ${walletAddress}`);
                    } else {
                        // Bot is offline - simulate collection
                        addChatMessage('', `‚ö†Ô∏è Distribution bot offline - simulating collection`, true);
                        addChatMessage('', `üéÅ ${walletAddress.slice(0, 6)}... collected ${totalAmount.toFixed(3)} APOCAT tokens!`, true);

                        // Move pending to claimed
                        this.claimedRewards.push(...this.pendingRewards);
                        this.pendingRewards = [];
                        localStorage.setItem('apocatClaimedRewards', JSON.stringify(this.claimedRewards));
                        localStorage.setItem('apocatPendingRewards', JSON.stringify(this.pendingRewards));

                        console.log(`ü™ô Simulated collection of ${totalAmount.toFixed(3)} APOCAT tokens`);
                    }
                } catch (error) {
                    console.error('‚ùå Error collecting rewards:', error);
                    addChatMessage('', `‚ùå Collection failed - please try again later`, true);
                }
            },

            async checkBotStatus() {
                try {
                    const response = await fetch('http://localhost:3000/api/status');
                    if (response.ok) {
                        const status = await response.json();
                        return { online: true, status: status };
                    }
                    return { online: false };
                } catch (error) {
                    return { online: false };
                }
            }
        };

        // Scoreboard system
        const scoreboard = {
            scores: JSON.parse(localStorage.getItem('apocatScores') || '[]'),

            addScore(entry) {
                const scoreEntry = {
                    ...entry,
                    timestamp: Date.now(),
                    date: new Date().toLocaleDateString()
                };

                this.scores.push(scoreEntry);
                this.scores.sort((a, b) => b.score - a.score);
                this.scores = this.scores.slice(0, 100);

                localStorage.setItem('apocatScores', JSON.stringify(this.scores));

                // Check for new high score reward
                rewardSystem.checkNewHighScore(scoreEntry.score);

                return {
                    rank: this.scores.findIndex(s => s.timestamp === scoreEntry.timestamp) + 1,
                    rewardInfo: { totalTokens: rewardSystem.getTotalPending(), reasons: [] }
                };
            },

            getTopScores(limit = 10) {
                return this.scores.slice(0, limit);
            }
        };

        // Utility functions
        function addAnimation(type, x, y, options = {}) {
            animations.push({
                type: type,
                x: x,
                y: y,
                time: 0,
                duration: options.duration || 1000,
                ...options
            });
        }

        function updateAnimations(deltaTime) {
            for (let i = animations.length - 1; i >= 0; i--) {
                animations[i].time += deltaTime;
                if (animations[i].time >= animations[i].duration) {
                    animations.splice(i, 1);
                }
            }
        }

        function activateStaminaBoost(duration = 5000) {
            staminaBoostActive = true;
            staminaBoostTimer = duration;
            console.log('‚ö° Stamina boost activated!');
        }

        function spawnBoss() {
            if (currentBoss || bossSpawned) return;

            const bossTypes = ['warlord', 'mothership', 'titan'];
            const bossType = bossTypes[Math.floor(Math.random() * bossTypes.length)];

            let bossEmoji, bossSize;
            if (bossType === 'warlord') {
                bossEmoji = 'üëπ'; // Apocalyptic warlord
                bossSize = 120;
            } else if (bossType === 'mothership') {
                bossEmoji = 'üõ∏'; // Alien mothership
                bossSize = 140;
            } else { // titan
                bossEmoji = 'ü§ñ'; // Giant mech titan
                bossSize = 160;
            }

            currentBoss = {
                x: canvas.width + 100,
                y: canvas.height / 2,
                vx: -25, // Slower than regular enemies
                vy: 0,
                size: bossSize,
                points: 100 + (round * 25), // More points
                type: bossType,
                layer: 'foreground',
                alpha: 1,
                emoji: bossEmoji,
                layerMultiplier: 2,
                health: 15, // Requires 15 hits
                maxHealth: 15,
                isHurt: false,
                hurtTimer: 0,
                isBoss: true
            };

            bossSpawned = true;
            playSound(sounds.bossSpawn);
            console.log(`üëπ BOSS SPAWNED! ${bossType} boss with ${currentBoss.health} HP!`);
        }

        function spawnZombie() {
            const side = Math.random() < 0.5 ? 'left' : 'right';
            const types = ['raider', 'drone', 'mech'];
            const type = types[Math.floor(Math.random() * types.length)];
            const layers = ['background', 'middle', 'foreground'];
            const layer = layers[Math.floor(Math.random() * layers.length)];

            let speed = 60 + (round - 1) * 15;
            let points = 10;
            let size = 50;
            let emoji = 'ü§ñ';

            if (type === 'raider') {
                speed *= 1.0;
                points = 10;
                emoji = 'üëπ'; // Apocalyptic raider
            } else if (type === 'drone') {
                speed *= 1.8;
                points = 15;
                emoji = 'üõ∏'; // Flying drone
            } else if (type === 'mech') {
                speed *= 0.7;
                points = 25;
                size = 60;
                emoji = 'ü§ñ'; // Heavy mech
            }

            let layerMultiplier = 1;
            let alpha = 1;
            let yRange = { min: 100, max: canvas.height - 200 };

            if (layer === 'background') {
                layerMultiplier = 0.6;
                alpha = 0.7;
                yRange = { min: 80, max: canvas.height * 0.4 };
            } else if (layer === 'middle') {
                layerMultiplier = 0.8;
                alpha = 0.85;
                yRange = { min: 120, max: canvas.height * 0.6 };
            } else {
                layerMultiplier = 1.2;
                alpha = 1;
                yRange = { min: 200, max: canvas.height * 0.85 };
            }

            // Base health increases every 5 rounds
            let baseHealth = 1 + Math.floor((round - 1) / 5);
            let health = baseHealth;
            let maxHealth = baseHealth;

            if (layerMultiplier >= 1.2) {
                health = baseHealth + 1; // Foreground enemies get +1 HP
                maxHealth = baseHealth + 1;
                points = Math.floor(points * layerMultiplier * 1.5);
            }

            const zombie = {
                x: side === 'left' ? -size : canvas.width + size,
                y: Math.random() * (yRange.max - yRange.min) + yRange.min,
                vx: (side === 'left' ? 1 : -1) * speed * layerMultiplier,
                vy: (Math.random() - 0.5) * 15,
                size: size * layerMultiplier,
                points: Math.floor(points * layerMultiplier),
                type: type,
                layer: layer,
                alpha: alpha,
                emoji: emoji,
                layerMultiplier: layerMultiplier,
                health: health,
                maxHealth: maxHealth,
                isHurt: false,
                hurtTimer: 0
            };

            zombies.push(zombie);
            console.log(`‚öîÔ∏è Spawned ${type} invader (${layer} layer) with ${health} HP`);
        }

        function spawnCatFood() {
            const food = {
                x: Math.random() * (canvas.width - 100) + 50,
                y: Math.random() * (canvas.height - 200) + 100,
                size: 40,
                lifeTime: 5000, // 5 seconds (shorter duration)
                emoji: 'üçñ'
            };
            catFood.push(food);
            console.log('üçñ Cat food spawned!');
        }

        function isInCollisionZone(x, y) {
            return collisionZones.some(zone =>
                x >= zone.x && x <= zone.x + zone.width &&
                y >= zone.y && y <= zone.y + zone.height
            );
        }

        function createExplosion(x, y) {
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 200,
                    vy: (Math.random() - 0.5) * 200,
                    life: 1.0,
                    color: `hsl(${Math.random() * 60 + 15}, 100%, 50%)`
                });
            }
        }

        function createPawSwipe(x, y) {
            const hitRadius = getHitRadius();
            pawSwipes.push({
                x: x,
                y: y,
                size: hitRadius * 2, // Make paw as big as hit circle
                life: 0.5
            });
        }

        function submitScore() {
            const accuracy = totalPaws > 0 ? Math.round((hits / totalPaws) * 100) : 0;

            const result = scoreboard.addScore({
                walletAddress: walletAddress || 'Anonymous',
                score: score,
                wave: round - 1,
                zombiesKilled: zombiesKilled,
                accuracy: accuracy
            });

            console.log('üèÜ Score submitted:', result);
            return result;
        }

        function buyUpgrade(upgradeKey) {
            const upgrade = upgrades[upgradeKey];
            if (coins >= upgrade.cost && upgrade.level < upgrade.maxLevel) {
                coins -= upgrade.cost;
                upgrade.level++;
                upgrade.cost = Math.floor(upgrade.cost * 1.5); // Increase cost for next level

                // Apply upgrade effects
                applyUpgrades();

                console.log(`üõí Bought ${upgrade.name} level ${upgrade.level}!`);
                return true;
            }
            return false;
        }

        function applyUpgrades() {
            // Reset to base values
            maxStamina = 100;
            staminaRegenRate = 8;

            // Apply upgrades
            maxStamina += upgrades.moreEnergy.level * 20; // +20 stamina per level
            staminaRegenRate += upgrades.energyRegen.level * 3; // +3 regen per level

            // Ensure current stamina doesn't exceed new max
            stamina = Math.min(stamina, maxStamina);
        }

        function getHitRadius() {
            return 25 + (upgrades.biggerPaw.level * 10); // Base 25px + 10px per level
        }

        function getDamageMultiplier() {
            return 1 + (upgrades.strongerPaw.level * 0.5); // +50% damage per level
        }

        // Drawing functions
        function drawBackground() {
            // Apocalyptic sky gradient
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            skyGradient.addColorStop(0, '#2F1B14'); // Dark brown
            skyGradient.addColorStop(0.3, '#8B4513'); // Saddle brown
            skyGradient.addColorStop(0.6, '#CD853F'); // Peru
            skyGradient.addColorStop(1, '#D2691E'); // Chocolate
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Wasteland ground with cracks
            const groundGradient = ctx.createLinearGradient(0, canvas.height - 150, 0, canvas.height);
            groundGradient.addColorStop(0, '#8B4513'); // Saddle brown
            groundGradient.addColorStop(0.5, '#A0522D'); // Sienna
            groundGradient.addColorStop(1, '#654321'); // Dark brown
            ctx.fillStyle = groundGradient;
            ctx.fillRect(0, canvas.height - 150, canvas.width, 150);

            // Cracked wasteland surface
            ctx.fillStyle = '#5D4037';
            ctx.fillRect(0, canvas.height - 120, canvas.width, 20);

            // Ground cracks and debris
            ctx.strokeStyle = '#3E2723';
            ctx.lineWidth = 2;
            for (let i = 0; i < 8; i++) {
                const x = (i * canvas.width / 8) + Math.random() * 50;
                ctx.beginPath();
                ctx.moveTo(x, canvas.height - 100);
                ctx.lineTo(x + Math.random() * 40 - 20, canvas.height - 60);
                ctx.stroke();
            }

            // Distant ruins silhouette
            ctx.fillStyle = '#1A1A1A';
            ctx.beginPath();
            ctx.moveTo(0, canvas.height * 0.4);
            for (let x = 0; x <= canvas.width; x += 50) {
                const height = canvas.height * (0.4 + Math.sin(x * 0.01) * 0.1);
                ctx.lineTo(x, height);
            }
            ctx.lineTo(canvas.width, canvas.height);
            ctx.lineTo(0, canvas.height);
            ctx.closePath();
            ctx.fill();

            // Floating ash particles
            ctx.fillStyle = 'rgba(200, 200, 200, 0.3)';
            for (let i = 0; i < 15; i++) {
                const x = (Date.now() * 0.02 + i * 50) % (canvas.width + 20);
                const y = 50 + Math.sin(Date.now() * 0.001 + i) * 30;
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Embers floating up
            ctx.fillStyle = 'rgba(255, 100, 0, 0.6)';
            for (let i = 0; i < 8; i++) {
                const x = Math.random() * canvas.width;
                const y = (canvas.height - Date.now() * 0.05 + i * 100) % canvas.height;
                ctx.beginPath();
                ctx.arc(x, y, 1, 0, Math.PI * 2);
                ctx.fill();
            }

            // drawCollisionZones(); // Removed for cleaner background
        }

        function drawCollisionZones() {
            collisionZones.forEach(zone => {
                // Apocalyptic obstacle colors
                let baseColor, emoji;
                if (zone.type === 'ruins') {
                    baseColor = '#4A4A4A'; // Dark gray ruins
                    emoji = 'üèöÔ∏è';
                } else if (zone.type === 'debris') {
                    baseColor = '#654321'; // Brown debris pile
                    emoji = 'ü™®';
                } else { // wreckage
                    baseColor = '#8B4513'; // Rusty wreckage
                    emoji = 'üí•';
                }

                // Draw shadow first
                ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                ctx.fillRect(zone.x + zone.shadowOffset, zone.y + zone.shadowOffset, zone.width, zone.height);

                // Draw main obstacle with gradient
                const gradient = ctx.createLinearGradient(zone.x, zone.y, zone.x, zone.y + zone.height);
                gradient.addColorStop(0, baseColor);
                gradient.addColorStop(0.7, '#2F2F2F');
                gradient.addColorStop(1, '#1A1A1A');
                ctx.fillStyle = gradient;
                ctx.fillRect(zone.x, zone.y, zone.width, zone.height);

                // Add texture/cracks
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.moveTo(zone.x + Math.random() * zone.width, zone.y);
                    ctx.lineTo(zone.x + Math.random() * zone.width, zone.y + zone.height);
                    ctx.stroke();
                }

                // Draw emoji
                ctx.fillStyle = '#fff';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeText(emoji, zone.x + zone.width/2, zone.y + zone.height/2 + 8);
                ctx.fillText(emoji, zone.x + zone.width/2, zone.y + zone.height/2 + 8);
            });
        }

        function drawZombie(zombie) {
            ctx.globalAlpha = zombie.alpha;

            if (zombie.isHurt && zombie.hurtTimer > 0) {
                ctx.globalCompositeOperation = 'multiply';
                ctx.fillStyle = '#ff6666';
                ctx.beginPath();
                ctx.arc(zombie.x, zombie.y, zombie.size * 0.6, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalCompositeOperation = 'source-over';
            }

            drawStylizedZombie(zombie);

            if (zombie.maxHealth > 1) {
                drawZombieHealthBar(zombie);
            }

            if (zombie.layer === 'foreground') {
                ctx.globalCompositeOperation = 'screen';
                ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
                ctx.beginPath();
                ctx.arc(zombie.x, zombie.y, zombie.size * 0.8, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalCompositeOperation = 'source-over';
            }

            ctx.globalAlpha = 1;
        }

        function drawStylizedZombie(zombie) {
            const halfSize = zombie.size / 2;
            const centerX = zombie.x;
            const centerY = zombie.y;

            // Goofy apocalyptic invader colors
            let bodyColor, accentColor, eyeColor;
            if (zombie.type === 'raider') {
                bodyColor = '#8B4513'; // Brown
                accentColor = '#654321'; // Dark brown
                eyeColor = '#FF6600'; // Orange
            } else if (zombie.type === 'drone') {
                bodyColor = '#666666'; // Gray
                accentColor = '#444444'; // Dark gray
                eyeColor = '#00FF00'; // Green
            } else { // mech
                bodyColor = '#444444'; // Dark gray
                accentColor = '#222222'; // Very dark gray
                eyeColor = '#FF0000'; // Red
            }

            if (zombie.type === 'raider') {
                // Draw shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(centerX + 3, centerY + halfSize + 5, halfSize * 0.8, halfSize * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();

                // Goofy raider body
                const bodyGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, halfSize);
                bodyGradient.addColorStop(0, bodyColor);
                bodyGradient.addColorStop(1, accentColor);
                ctx.fillStyle = bodyGradient;

                // Main body (oval)
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, halfSize * 0.7, halfSize * 0.9, 0, 0, Math.PI * 2);
                ctx.fill();

                // Goggles
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(centerX - halfSize * 0.3, centerY - halfSize * 0.4, halfSize * 0.15, 0, Math.PI * 2);
                ctx.arc(centerX + halfSize * 0.3, centerY - halfSize * 0.4, halfSize * 0.15, 0, Math.PI * 2);
                ctx.fill();

                // Goggle straps
                ctx.strokeStyle = '#B8860B';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(centerX, centerY - halfSize * 0.4, halfSize * 0.6, 0, Math.PI);
                ctx.stroke();

                // Bandana/scarf
                ctx.fillStyle = '#DC143C';
                ctx.beginPath();
                ctx.ellipse(centerX, centerY + halfSize * 0.2, halfSize * 0.5, halfSize * 0.2, 0, 0, Math.PI * 2);
                ctx.fill();

            } else if (zombie.type === 'drone') {
                // Draw shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(centerX + 3, centerY + halfSize + 5, halfSize * 0.8, halfSize * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();

                // Flying drone body
                ctx.fillStyle = bodyColor;
                ctx.fillRect(centerX - halfSize * 0.6, centerY - halfSize * 0.3, halfSize * 1.2, halfSize * 0.6);

                // Drone details
                ctx.fillStyle = accentColor;
                ctx.fillRect(centerX - halfSize * 0.4, centerY - halfSize * 0.2, halfSize * 0.8, halfSize * 0.4);

                // Propellers (spinning animation)
                const spin = Date.now() * 0.02;
                ctx.strokeStyle = '#999';
                ctx.lineWidth = 3;

                // Four propellers
                const propPositions = [
                    {x: centerX - halfSize * 0.8, y: centerY - halfSize * 0.6},
                    {x: centerX + halfSize * 0.8, y: centerY - halfSize * 0.6},
                    {x: centerX - halfSize * 0.8, y: centerY + halfSize * 0.6},
                    {x: centerX + halfSize * 0.8, y: centerY + halfSize * 0.6}
                ];

                propPositions.forEach((prop, i) => {
                    const angle = spin + (i * Math.PI / 2);
                    ctx.beginPath();
                    ctx.moveTo(prop.x - Math.cos(angle) * halfSize * 0.3, prop.y);
                    ctx.lineTo(prop.x + Math.cos(angle) * halfSize * 0.3, prop.y);
                    ctx.stroke();
                });

                // Antenna
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY - halfSize * 0.3);
                ctx.lineTo(centerX, centerY - halfSize * 0.8);
                ctx.stroke();

                // Antenna tip
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(centerX, centerY - halfSize * 0.8, 3, 0, Math.PI * 2);
                ctx.fill();

            } else { // mech
                // Draw shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(centerX + 3, centerY + halfSize + 5, halfSize * 0.8, halfSize * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();

                // Chunky mech body
                ctx.fillStyle = bodyColor;
                ctx.fillRect(centerX - halfSize * 0.8, centerY - halfSize * 0.9, halfSize * 1.6, halfSize * 1.8);

                // Mech chest panel
                ctx.fillStyle = accentColor;
                ctx.fillRect(centerX - halfSize * 0.6, centerY - halfSize * 0.7, halfSize * 1.2, halfSize * 0.8);

                // Mech arms
                ctx.fillStyle = bodyColor;
                ctx.fillRect(centerX - halfSize * 1.2, centerY - halfSize * 0.5, halfSize * 0.3, halfSize * 1.0);
                ctx.fillRect(centerX + halfSize * 0.9, centerY - halfSize * 0.5, halfSize * 0.3, halfSize * 1.0);

                // Mech legs
                ctx.fillRect(centerX - halfSize * 0.4, centerY + halfSize * 0.5, halfSize * 0.3, halfSize * 0.6);
                ctx.fillRect(centerX + halfSize * 0.1, centerY + halfSize * 0.5, halfSize * 0.3, halfSize * 0.6);

                // Mech details - vents
                ctx.fillStyle = '#FF6600';
                for (let i = 0; i < 3; i++) {
                    ctx.fillRect(centerX - halfSize * 0.5 + i * halfSize * 0.2, centerY - halfSize * 0.6, halfSize * 0.1, halfSize * 0.2);
                }

                // Shoulder pads
                ctx.fillStyle = accentColor;
                ctx.beginPath();
                ctx.arc(centerX - halfSize * 0.9, centerY - halfSize * 0.6, halfSize * 0.2, 0, Math.PI * 2);
                ctx.arc(centerX + halfSize * 0.9, centerY - halfSize * 0.6, halfSize * 0.2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw glowing eyes for all types
            ctx.fillStyle = eyeColor;
            ctx.shadowColor = eyeColor;
            ctx.shadowBlur = 8 * zombie.layerMultiplier;

            const eyeSize = 5 * zombie.layerMultiplier;
            let eyeOffset, eyeY;

            if (zombie.type === 'raider') {
                eyeOffset = 12 * zombie.layerMultiplier;
                eyeY = centerY - halfSize * 0.4; // Behind goggles
            } else if (zombie.type === 'drone') {
                eyeOffset = 0; // Single center eye
                eyeY = centerY;
                ctx.beginPath();
                ctx.arc(centerX, eyeY, eyeSize * 1.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                return; // Skip the two-eye drawing below
            } else { // mech
                eyeOffset = 15 * zombie.layerMultiplier;
                eyeY = centerY - halfSize * 0.5;
            }

            // Draw two eyes for raider and mech
            ctx.beginPath();
            ctx.arc(centerX - eyeOffset, eyeY, eyeSize, 0, Math.PI * 2);
            ctx.arc(centerX + eyeOffset, eyeY, eyeSize, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowBlur = 0;
        }

        function drawZombieHealthBar(zombie) {
            const barWidth = zombie.size * 0.8;
            const barHeight = 6;
            const barX = zombie.x - barWidth / 2;
            const barY = zombie.y - zombie.size / 2 - 15;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(barX - 1, barY - 1, barWidth + 2, barHeight + 2);

            const healthPercent = zombie.health / zombie.maxHealth;
            const healthColor = healthPercent > 0.5 ? '#00ff00' : '#ff4444';

            ctx.fillStyle = healthColor;
            ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);

            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.strokeRect(barX, barY, barWidth, barHeight);
        }

        // Game loop and main functions
        function gameLoop() {
            const currentTime = Date.now();
            const deltaTime = Math.min(currentTime - (gameLoop.lastTime || currentTime), 50);
            gameLoop.lastTime = currentTime;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (gameState === 'menu') {
                drawMenu();
            } else if (gameState === 'playing') {
                updateGame(deltaTime);
                drawGame();
            } else if (gameState === 'shop') {
                drawShop();
            } else if (gameState === 'gameOver') {
                drawGameOver();
            } else if (gameState === 'scoreboard') {
                drawScoreboard();
            }

            requestAnimationFrame(gameLoop);
        }

        function drawApocatLogo(centerX, centerY, size) {
            const scale = size / 100; // Base size 100

            // Cat head
            ctx.fillStyle = '#8B8B8B';
            ctx.beginPath();
            ctx.ellipse(centerX, centerY + 10 * scale, 45 * scale, 40 * scale, 0, 0, Math.PI * 2);
            ctx.fill();

            // Cat ears
            ctx.fillStyle = '#8B8B8B';
            ctx.beginPath();
            ctx.moveTo(centerX - 30 * scale, centerY - 25 * scale);
            ctx.lineTo(centerX - 15 * scale, centerY - 50 * scale);
            ctx.lineTo(centerX - 5 * scale, centerY - 25 * scale);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(centerX + 5 * scale, centerY - 25 * scale);
            ctx.lineTo(centerX + 15 * scale, centerY - 50 * scale);
            ctx.lineTo(centerX + 30 * scale, centerY - 25 * scale);
            ctx.closePath();
            ctx.fill();

            // Ear inner
            ctx.fillStyle = '#FF6B47';
            ctx.beginPath();
            ctx.moveTo(centerX - 25 * scale, centerY - 30 * scale);
            ctx.lineTo(centerX - 15 * scale, centerY - 45 * scale);
            ctx.lineTo(centerX - 10 * scale, centerY - 30 * scale);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(centerX + 10 * scale, centerY - 30 * scale);
            ctx.lineTo(centerX + 15 * scale, centerY - 45 * scale);
            ctx.lineTo(centerX + 25 * scale, centerY - 30 * scale);
            ctx.closePath();
            ctx.fill();

            // Goggles frame
            ctx.strokeStyle = '#4A4A4A';
            ctx.lineWidth = 4 * scale;
            ctx.beginPath();
            ctx.arc(centerX - 15 * scale, centerY - 5 * scale, 18 * scale, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(centerX + 15 * scale, centerY - 5 * scale, 18 * scale, 0, Math.PI * 2);
            ctx.stroke();

            // Goggle lenses
            ctx.fillStyle = '#FFD700';
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.arc(centerX - 15 * scale, centerY - 5 * scale, 15 * scale, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(centerX + 15 * scale, centerY - 5 * scale, 15 * scale, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            // Goggle reflections
            ctx.fillStyle = '#FFF';
            ctx.globalAlpha = 0.6;
            ctx.beginPath();
            ctx.ellipse(centerX - 18 * scale, centerY - 8 * scale, 8 * scale, 10 * scale, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(centerX + 12 * scale, centerY - 8 * scale, 8 * scale, 10 * scale, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            // Cat eyes (behind goggles)
            ctx.fillStyle = '#00FF00';
            ctx.shadowColor = '#00FF00';
            ctx.shadowBlur = 8 * scale;
            ctx.beginPath();
            ctx.arc(centerX - 15 * scale, centerY + 5 * scale, 8 * scale, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(centerX + 15 * scale, centerY + 5 * scale, 8 * scale, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Cat pupils
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.ellipse(centerX - 15 * scale, centerY + 5 * scale, 3 * scale, 6 * scale, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(centerX + 15 * scale, centerY + 5 * scale, 3 * scale, 6 * scale, 0, 0, Math.PI * 2);
            ctx.fill();

            // Cat nose
            ctx.fillStyle = '#FF6600';
            ctx.beginPath();
            ctx.moveTo(centerX, centerY + 15 * scale);
            ctx.lineTo(centerX - 5 * scale, centerY + 20 * scale);
            ctx.lineTo(centerX + 5 * scale, centerY + 20 * scale);
            ctx.closePath();
            ctx.fill();

            // Cat mouth
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2 * scale;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY + 22 * scale);
            ctx.quadraticCurveTo(centerX - 5 * scale, centerY + 25 * scale, centerX - 10 * scale, centerY + 22 * scale);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(centerX, centerY + 22 * scale);
            ctx.quadraticCurveTo(centerX + 5 * scale, centerY + 25 * scale, centerX + 10 * scale, centerY + 22 * scale);
            ctx.stroke();

            // Whiskers
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2 * scale;
            ctx.beginPath();
            ctx.moveTo(centerX - 35 * scale, centerY + 10 * scale);
            ctx.lineTo(centerX - 20 * scale, centerY + 8 * scale);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(centerX - 35 * scale, centerY + 15 * scale);
            ctx.lineTo(centerX - 20 * scale, centerY + 15 * scale);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(centerX + 20 * scale, centerY + 8 * scale);
            ctx.lineTo(centerX + 35 * scale, centerY + 10 * scale);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(centerX + 20 * scale, centerY + 15 * scale);
            ctx.lineTo(centerX + 35 * scale, centerY + 15 * scale);
            ctx.stroke();
        }

        function drawMenu() {
            drawBackground();

            const overlayGradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, canvas.width/2);
            overlayGradient.addColorStop(0, 'rgba(26, 26, 46, 0.7)');
            overlayGradient.addColorStop(1, 'rgba(0, 0, 0, 0.9)');
            ctx.fillStyle = overlayGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw APOCAT logo
            try {
                drawApocatLogo(canvas.width/2, canvas.height/2 - 100, 60);
            } catch (e) {
                // Fallback simple logo
                ctx.fillStyle = APOCAT_COLORS.catOrange;
                ctx.shadowColor = APOCAT_COLORS.catOrange;
                ctx.shadowBlur = 20;
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üê±', canvas.width/2, canvas.height/2 - 80);
                ctx.shadowBlur = 0;
            }

            ctx.textAlign = 'center';

            ctx.fillStyle = APOCAT_COLORS.catOrange;
            ctx.font = 'bold 36px Arial';
            ctx.shadowColor = APOCAT_COLORS.catOrange;
            ctx.shadowBlur = 20;
            ctx.fillText('apoCATlypse Meow', canvas.width / 2, canvas.height / 2 - 30);

            ctx.fillStyle = APOCAT_COLORS.warningYellow;
            ctx.font = 'bold 24px Arial';
            ctx.shadowColor = APOCAT_COLORS.warningYellow;
            ctx.shadowBlur = 12;
            ctx.fillText('üê± APOCAT üê±', canvas.width / 2, canvas.height / 2 + 5);

            ctx.shadowBlur = 0;

            ctx.fillStyle = '#fff';
            ctx.font = '16px Arial';
            ctx.fillText('‚öîÔ∏è Defend the wasteland from invaders!', canvas.width / 2, canvas.height / 2 + 40);
            ctx.fillText('ü™ô Earn apoCATlypse Meow - APOCAT tokens!', canvas.width / 2, canvas.height / 2 + 60);
            ctx.fillText('üëπ Defeat bosses for bonus rewards!', canvas.width / 2, canvas.height / 2 + 80);

            ctx.fillStyle = APOCAT_COLORS.energyGreen;
            ctx.fillRect(canvas.width / 2 - 100, canvas.height / 2 + 100, 200, 45);
            ctx.strokeStyle = APOCAT_COLORS.energyGreen;
            ctx.lineWidth = 2;
            ctx.shadowColor = APOCAT_COLORS.energyGreen;
            ctx.shadowBlur = 8;
            ctx.strokeRect(canvas.width / 2 - 100, canvas.height / 2 + 100, 200, 45);
            ctx.shadowBlur = 0;

            ctx.fillStyle = '#000';
            ctx.font = 'bold 18px Arial';
            ctx.fillText('üéÆ START GAME', canvas.width / 2, canvas.height / 2 + 128);

            ctx.fillStyle = walletAddress ? APOCAT_COLORS.glowBlue : '#666666';
            ctx.fillRect(canvas.width / 2 - 100, canvas.height / 2 + 155, 200, 35);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px Arial';
            if (walletAddress) {
                ctx.fillText(`üí∞ ${walletAddress.slice(0, 6)}...${walletAddress.slice(-4)}`, canvas.width / 2, canvas.height / 2 + 177);
            } else {
                ctx.fillText('üí∞ Connect Wallet (Test)', canvas.width / 2, canvas.height / 2 + 177);
            }

            ctx.fillStyle = APOCAT_COLORS.catOrange;
            ctx.fillRect(canvas.width / 2 - 100, canvas.height / 2 + 200, 200, 35);
            ctx.fillStyle = '#fff';
            ctx.fillText('üèÜ LEADERBOARD', canvas.width / 2, canvas.height / 2 + 222);
        }

        function updateGame(deltaTime) {
            if (roundStartTime === 0) {
                roundStartTime = Date.now();
            }

            const elapsed = (Date.now() - roundStartTime) / 1000;
            roundTimer = Math.max(0, 30 - elapsed);

            // Spawn boss when 15 seconds left
            if (roundTimer <= 15 && !bossSpawned) {
                spawnBoss();
            }

            if (roundTimer <= 0) {
                // Check if boss is still alive - INSTANT GAME OVER
                if (currentBoss) {
                    gameState = 'gameOver';
                    playSound(sounds.playerDeath);
                    submitScore();
                    console.log('üëπ BOSS SURVIVED! INSTANT GAME OVER!');
                    addChatMessage('', `üíÄ ${walletAddress ? walletAddress.slice(0, 6) + '...' : 'Anonymous'} was defeated by the boss!`, true);
                    return;
                }

                zombiesSurvived += zombies.length;
                console.log(`‚è∞ Round ${round} ended! Invaders survived this round: ${zombies.length}, Total: ${zombiesSurvived}`);

                if (zombiesSurvived >= maxSurvivors) {
                    gameState = 'gameOver';
                    submitScore();
                    console.log('üéÆ Game Over! Too many invaders escaped!');
                    return;
                } else {
                    // Level completed - go to shop
                    extraLives++;
                    maxSurvivors = baseLives + extraLives;

                    // Award APOCAT tokens for round completion
                    rewardSystem.awardRoundCompletion();

                    // Check for new round record
                    rewardSystem.checkNewRoundRecord(round);

                    // Check for perfect round (no misses)
                    if (totalPaws > 0 && missStreak === 0 && hits === totalPaws) {
                        rewardSystem.awardPerfectRound();
                    }

                    // Award boss defeat bonus
                    if (bossSpawned && !currentBoss) {
                        rewardSystem.awardBossDefeat();
                    }

                    // Award coins based on performance
                    const roundBonus = round * 10;
                    const killBonus = zombiesKilled * 2;
                    const accuracyBonus = totalPaws > 0 ? Math.floor((hits / totalPaws) * 50) : 0;
                    const bossBonus = bossSpawned && !currentBoss ? 50 : 0; // Bonus for defeating boss
                    const coinsEarned = roundBonus + killBonus + accuracyBonus + bossBonus;
                    coins += coinsEarned;

                    round++;
                    zombies = [];
                    catFood = [];
                    currentBoss = null;
                    bossSpawned = false;
                    zombiesSurvived = 0;

                    gameState = 'shop';
                    console.log(`üéØ Level ${round - 1} completed! Earned ${coinsEarned} coins (Boss bonus: ${bossBonus}). Total: ${coins}`);
                }
            }

            // Only spawn zombies if no boss is active
            if (!currentBoss) {
                zombieSpawnTimer += deltaTime;
                // More random spawn intervals
                const baseSpawnRate = Math.max(800, 1500 - (round - 1) * 100);
                const randomVariation = Math.random() * 1000; // 0-1000ms random variation
                const spawnRate = baseSpawnRate + randomVariation;
                if (zombieSpawnTimer > spawnRate) {
                    spawnZombie();
                    zombieSpawnTimer = 0;
                }
            }

            // Cat food spawning (less frequent, more important)
            foodSpawnTimer += deltaTime;
            if (foodSpawnTimer > foodSpawnInterval && catFood.length < 2) { // Max 2 food items
                spawnCatFood();
                foodSpawnTimer = 0;
            }

            // Update boss
            if (currentBoss) {
                currentBoss.x += currentBoss.vx * (deltaTime / 1000);
                currentBoss.y += currentBoss.vy * (deltaTime / 1000);

                if (currentBoss.hurtTimer > 0) {
                    currentBoss.hurtTimer -= deltaTime;
                    if (currentBoss.hurtTimer <= 0) {
                        currentBoss.isHurt = false;
                    }
                }

                // Boss escaped
                if (currentBoss.x < -200) {
                    zombiesSurvived++;
                    currentBoss = null;
                    console.log('üëπ Boss escaped!');

                    if (zombiesSurvived >= maxSurvivors) {
                        gameState = 'gameOver';
                        submitScore();
                        console.log('üéÆ Game Over! Boss escaped!');
                        return;
                    }
                }
            }

            for (let i = zombies.length - 1; i >= 0; i--) {
                const zombie = zombies[i];
                zombie.x += zombie.vx * (deltaTime / 1000);
                zombie.y += zombie.vy * (deltaTime / 1000);

                if (zombie.hurtTimer > 0) {
                    zombie.hurtTimer -= deltaTime;
                    if (zombie.hurtTimer <= 0) {
                        zombie.isHurt = false;
                    }
                }

                if (zombie.x < -100 || zombie.x > canvas.width + 100) {
                    zombiesSurvived++;
                    zombies.splice(i, 1);
                    console.log(`üíÄ Invader escaped! Total escaped: ${zombiesSurvived}`);

                    if (zombiesSurvived >= maxSurvivors) {
                        gameState = 'gameOver';
                        submitScore();
                        console.log('üéÆ Game Over! Too many invaders escaped!');
                        return;
                    }
                }
            }

            // Update cat food
            for (let i = catFood.length - 1; i >= 0; i--) {
                const food = catFood[i];
                food.lifeTime -= deltaTime;

                // Food disappears after 5 seconds (shorter duration)
                if (food.lifeTime <= 0) {
                    catFood.splice(i, 1);
                    console.log('üçñ Cat food disappeared!');
                }
            }

            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.x += particle.vx * (deltaTime / 1000);
                particle.y += particle.vy * (deltaTime / 1000);
                particle.life -= deltaTime / 1000;

                if (particle.life <= 0) {
                    particles.splice(i, 1);
                }
            }

            for (let i = pawSwipes.length - 1; i >= 0; i--) {
                const swipe = pawSwipes[i];
                swipe.life -= 0.02;

                if (swipe.life <= 0) {
                    pawSwipes.splice(i, 1);
                }
            }

            if (comboTimer > 0) {
                comboTimer -= deltaTime;
                if (comboTimer <= 0) {
                    comboCount = 0;
                }
            }

            const currentStaminaRegenRate = staminaBoostActive ? staminaRegenRate * 3 : staminaRegenRate;
            if (stamina < maxStamina) {
                const regenBonus = stamina < 20 ? 2 : 1;
                stamina = Math.min(maxStamina, stamina + (currentStaminaRegenRate * regenBonus * deltaTime / 1000));
            }

            if (staminaBoostActive) {
                staminaBoostTimer -= deltaTime;
                if (staminaBoostTimer <= 0) {
                    staminaBoostActive = false;
                    console.log('‚ö° Stamina boost ended');
                }
            }

            updateAnimations(deltaTime);
        }

        function drawGame() {
            drawBackground();

            zombies.forEach(zombie => drawZombie(zombie));

            // Draw cat food
            catFood.forEach(food => {
                ctx.save();
                ctx.font = `${food.size}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Add pulsing effect
                const pulse = 1 + Math.sin(Date.now() * 0.005) * 0.1;
                ctx.scale(pulse, pulse);

                ctx.fillText(food.emoji, food.x / pulse, food.y / pulse);
                ctx.restore();
            });

            // Draw boss
            if (currentBoss) {
                drawBoss(currentBoss);
            }

            drawParticles();
            drawPawSwipes();
            drawAnimations();
            drawEnhancedUI();
            drawPawCursor();
        }

        function drawBoss(boss) {
            ctx.globalAlpha = boss.alpha;

            // Boss hurt effect
            if (boss.isHurt && boss.hurtTimer > 0) {
                ctx.globalCompositeOperation = 'multiply';
                ctx.fillStyle = '#ff6666';
                ctx.beginPath();
                ctx.arc(boss.x, boss.y, boss.size * 0.6, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalCompositeOperation = 'source-over';
            }

            // Boss warning aura
            ctx.globalCompositeOperation = 'screen';
            ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.arc(boss.x, boss.y, boss.size * 1.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalCompositeOperation = 'source-over';

            // Draw boss using enhanced zombie style but bigger
            drawStylizedZombie(boss);

            // Boss health bar (bigger and more prominent)
            const barWidth = boss.size * 1.2;
            const barHeight = 12;
            const barX = boss.x - barWidth / 2;
            const barY = boss.y - boss.size / 2 - 25;

            // Health bar background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(barX - 2, barY - 2, barWidth + 4, barHeight + 4);

            // Health bar fill
            const healthPercent = boss.health / boss.maxHealth;
            const healthColor = healthPercent > 0.6 ? '#ff6600' :
                               healthPercent > 0.3 ? '#ff4444' : '#ff0000';

            ctx.fillStyle = healthColor;
            ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);

            // Health bar border
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(barX, barY, barWidth, barHeight);

            // Boss label
            ctx.fillStyle = '#ff0000';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 8;
            ctx.fillText('üëπ BOSS', boss.x, barY - 10);
            ctx.shadowBlur = 0;

            ctx.globalAlpha = 1;
        }

        function drawParticles() {
            particles.forEach(particle => {
                ctx.globalAlpha = particle.life;
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        function drawPawSwipes() {
            pawSwipes.forEach(swipe => {
                ctx.globalAlpha = swipe.life;
                ctx.fillStyle = '#ffaa44';
                ctx.font = `${swipe.size || 24}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText('üêæ', swipe.x, swipe.y);
            });
            ctx.globalAlpha = 1;
        }

        function drawAnimations() {
            animations.forEach(anim => {
                const progress = anim.time / anim.duration;
                ctx.globalAlpha = 1 - progress;

                switch (anim.type) {
                    case 'score_popup':
                        ctx.fillStyle = '#00ff88';
                        ctx.font = 'bold 20px Arial';
                        ctx.textAlign = 'center';
                        ctx.shadowColor = '#00ff88';
                        ctx.shadowBlur = 6;
                        ctx.fillText(`+${anim.points}`, anim.x, anim.y - progress * 40);
                        ctx.shadowBlur = 0;
                        break;

                    case 'combo_popup':
                        const scale = 1 + (1 - progress) * 0.5;
                        ctx.save();
                        ctx.translate(anim.x, anim.y - progress * 50);
                        ctx.scale(scale, scale);

                        ctx.fillStyle = '#ffaa44';
                        ctx.font = 'bold 24px Arial';
                        ctx.textAlign = 'center';
                        ctx.shadowColor = '#ffaa44';
                        ctx.shadowBlur = 10;
                        ctx.fillText(`${anim.combo}x COMBO!`, 0, -20);

                        ctx.fillStyle = '#00ff88';
                        ctx.font = 'bold 18px Arial';
                        ctx.shadowColor = '#00ff88';
                        ctx.shadowBlur = 8;
                        ctx.fillText(`+${anim.points}`, 0, 5);

                        ctx.shadowBlur = 0;
                        ctx.restore();
                        break;

                    case 'damage_popup':
                        ctx.fillStyle = '#ffaa44';
                        ctx.font = 'bold 16px Arial';
                        ctx.textAlign = 'center';
                        ctx.shadowColor = '#ffaa44';
                        ctx.shadowBlur = 6;
                        ctx.fillText(anim.text || 'HIT!', anim.x, anim.y - progress * 30);
                        ctx.shadowBlur = 0;
                        break;

                    case 'catfood_collected':
                        const collectScale = 1 + progress * 2;
                        ctx.save();
                        ctx.translate(anim.x, anim.y - progress * 40);
                        ctx.scale(collectScale, collectScale);

                        ctx.fillStyle = '#ffaa44';
                        ctx.font = 'bold 20px Arial';
                        ctx.textAlign = 'center';
                        ctx.shadowColor = '#ffaa44';
                        ctx.shadowBlur = 10;
                        ctx.fillText('ENERGY BOOST!', 0, -10);

                        ctx.fillStyle = '#00ff88';
                        ctx.font = '16px Arial';
                        ctx.fillText('üçñ +100% Stamina', 0, 10);

                        ctx.shadowBlur = 0;
                        ctx.restore();
                        break;

                    case 'boss_defeated':
                        const bossScale = 1 + (1 - progress) * 1.5;
                        ctx.save();
                        ctx.translate(anim.x, anim.y);
                        ctx.scale(bossScale, bossScale);

                        ctx.fillStyle = '#ff6600';
                        ctx.font = 'bold 48px Arial';
                        ctx.textAlign = 'center';
                        ctx.shadowColor = '#ff6600';
                        ctx.shadowBlur = 20;
                        ctx.fillText('üëπ BOSS DEFEATED! üëπ', 0, 0);

                        ctx.shadowBlur = 0;
                        ctx.restore();
                        break;

                    case 'level_complete':
                        if (progress < 0.8) {
                            ctx.save();
                            ctx.translate(anim.x, anim.y);

                            const levelScale = 1 + 0.5 * Math.sin(anim.time / 200);
                            ctx.scale(levelScale, levelScale);

                            ctx.fillStyle = '#ffaa44';
                            ctx.font = 'bold 36px Arial';
                            ctx.textAlign = 'center';
                            ctx.shadowColor = '#ffaa44';
                            ctx.shadowBlur = 15;
                            ctx.fillText('LEVEL COMPLETE!', 0, -30);

                            ctx.fillStyle = '#00ff88';
                            ctx.font = 'bold 24px Arial';
                            ctx.shadowColor = '#00ff88';
                            ctx.shadowBlur = 10;
                            ctx.fillText(`üíñ Extra Life Gained!`, 0, 10);

                            ctx.fillStyle = '#fff';
                            ctx.font = '18px Arial';
                            ctx.shadowColor = '#000';
                            ctx.shadowBlur = 8;
                            ctx.fillText(`Total Lives: ${anim.newLives}`, 0, 40);

                            ctx.shadowBlur = 0;
                            ctx.restore();
                        }
                        break;
                }
            });
            ctx.globalAlpha = 1;
        }

        function drawEnhancedUI() {
            // Top-left info box
            drawTopLeftInfo();

            const livesRemaining = maxSurvivors - zombiesSurvived;
            const livesX = canvas.width - 200;
            const livesY = 20;
            const livesWidth = 180;
            const livesHeight = 80;

            const livesColor = livesRemaining <= 1 ? APOCAT_COLORS.catOrange :
                              livesRemaining <= 2 ? APOCAT_COLORS.warningYellow :
                              APOCAT_COLORS.energyGreen;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(livesX, livesY, livesWidth, livesHeight);

            ctx.strokeStyle = livesColor;
            ctx.lineWidth = 3;
            ctx.strokeRect(livesX, livesY, livesWidth, livesHeight);

            ctx.fillStyle = livesColor;
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Lives Remaining', livesX + livesWidth/2, livesY + 20);

            ctx.font = 'bold 20px Arial';
            let heartsText = '';
            for (let i = 0; i < maxSurvivors; i++) {
                heartsText += i < livesRemaining ? 'üíñ' : 'üñ§';
            }
            ctx.fillText(heartsText, livesX + livesWidth/2, livesY + 45);

            drawBigStaminaBar();

            if (comboCount > 1 && comboTimer > 0) {
                drawComboDisplay();
            }
        }

        function drawBigStaminaBar() {
            const barWidth = canvas.width - 40;
            const barHeight = 25;
            const barX = 20;
            const barY = canvas.height - 40;

            const staminaPercent = stamina / maxStamina;
            let barColor = staminaPercent > 0.6 ? APOCAT_COLORS.energyGreen :
                          staminaPercent > 0.3 ? APOCAT_COLORS.warningYellow :
                          APOCAT_COLORS.catOrange;

            if (staminaBoostActive) {
                barColor = APOCAT_COLORS.glowBlue;
            }

            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(barX - 2, barY - 2, barWidth + 4, barHeight + 4);

            ctx.strokeStyle = barColor;
            ctx.lineWidth = 2;
            if (staminaPercent < 0.2) {
                ctx.shadowColor = barColor;
                ctx.shadowBlur = 8 + 4 * Math.sin(Date.now() / 150);
            }
            ctx.strokeRect(barX, barY, barWidth, barHeight);
            ctx.shadowBlur = 0;

            const fillGradient = ctx.createLinearGradient(barX, barY, barX + barWidth, barY);
            fillGradient.addColorStop(0, barColor);
            fillGradient.addColorStop(1, barColor + '80');
            ctx.fillStyle = fillGradient;
            ctx.fillRect(barX, barY, barWidth * staminaPercent, barHeight);

            for (let i = 1; i < 10; i++) {
                const segmentX = barX + (barWidth / 10) * i;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(segmentX, barY);
                ctx.lineTo(segmentX, barY + barHeight);
                ctx.stroke();
            }

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#000';
            ctx.shadowBlur = 3;
            const statusText = staminaBoostActive ? 'APOCAT ENERGY - BOOSTED!' : 'APOCAT ENERGY';
            ctx.fillText(`${statusText} ${Math.floor(staminaPercent * 100)}%`, canvas.width / 2, barY + 17);
            ctx.shadowBlur = 0;
        }

        function drawComboDisplay() {
            if (comboCount <= 0) return;

            const comboX = canvas.width / 2;
            const comboY = 80;

            const comboAlpha = Math.min(1, comboTimer / 1000);
            ctx.globalAlpha = comboAlpha;

            // Apocalyptic style background with darker colors
            const comboBg = ctx.createRadialGradient(comboX, comboY, 0, comboX, comboY, 90);
            comboBg.addColorStop(0, 'rgba(255, 100, 0, 0.9)'); // Fiery orange
            comboBg.addColorStop(0.7, 'rgba(139, 69, 19, 0.6)'); // Dark brown
            comboBg.addColorStop(1, 'rgba(0, 0, 0, 0.3)'); // Black edge
            ctx.fillStyle = comboBg;
            ctx.beginPath();
            ctx.arc(comboX, comboY, 70, 0, Math.PI * 2);
            ctx.fill();

            // Add jagged border effect
            ctx.strokeStyle = '#ff6600';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 3]);
            ctx.stroke();
            ctx.setLineDash([]);

            const pulse = 1 + 0.3 * Math.sin(Date.now() / 120);
            ctx.save();
            ctx.translate(comboX, comboY);
            ctx.scale(pulse, pulse);

            // Cat paw emoji with combo count
            ctx.font = 'bold 42px Arial';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#ff6600';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.strokeText(`üêæ${comboCount}`, 0, -8);
            ctx.fillText(`üêæ${comboCount}`, 0, -8);

            ctx.fillStyle = '#ffdd44';
            ctx.font = 'bold 14px Arial';
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 1;
            ctx.strokeText('FURY COMBO', 0, 18);
            ctx.fillText('FURY COMBO', 0, 18);

            ctx.shadowBlur = 0;
            ctx.restore();
            ctx.globalAlpha = 1;
        }

        function drawTopLeftInfo() {
            const infoX = 20;
            const infoY = 20;
            const infoWidth = 200;
            const infoHeight = 100;

            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(infoX, infoY, infoWidth, infoHeight);

            // Border
            ctx.strokeStyle = APOCAT_COLORS.warningYellow;
            ctx.lineWidth = 2;
            ctx.strokeRect(infoX, infoY, infoWidth, infoHeight);

            // Round info
            ctx.fillStyle = APOCAT_COLORS.warningYellow;
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`üéØ Round: ${round}`, infoX + 10, infoY + 25);

            // Time remaining with countdown effect
            const timeLeft = Math.ceil(roundTimer);
            if (timeLeft <= 10 && timeLeft > 0) {
                // Big countdown in center for last 10 seconds
                ctx.save();
                ctx.font = 'bold 60px Arial';
                ctx.fillStyle = timeLeft <= 3 ? '#ff0000' : APOCAT_COLORS.catOrange;
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                const pulse = 1 + Math.sin(Date.now() * 0.01) * 0.2;
                ctx.scale(pulse, pulse);

                ctx.strokeText(timeLeft.toString(), (canvas.width / 2) / pulse, (canvas.height / 2 - 100) / pulse);
                ctx.fillText(timeLeft.toString(), (canvas.width / 2) / pulse, (canvas.height / 2 - 100) / pulse);
                ctx.restore();

                // Small timer in UI
                ctx.fillStyle = APOCAT_COLORS.catOrange;
                ctx.font = '16px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`‚è∞ Time: ${timeLeft}s`, infoX + 10, infoY + 45);
            } else {
                // Normal timer display
                ctx.fillStyle = '#fff';
                ctx.fillText(`‚è∞ Time: ${timeLeft}s`, infoX + 10, infoY + 45);
            }

            // Coins
            ctx.fillStyle = APOCAT_COLORS.energyGreen;
            ctx.fillText(`üí∞ Coins: ${coins}`, infoX + 10, infoY + 65);

            // Score
            ctx.fillStyle = '#fff';
            ctx.font = '14px Arial';
            ctx.fillText(`Score: ${score}`, infoX + 10, infoY + 85);
        }

        function drawPawCursor() {
            // Show hit radius if upgraded
            if (upgrades.biggerPaw.level > 0) {
                ctx.strokeStyle = 'rgba(255, 170, 68, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(mouse.x, mouse.y, getHitRadius(), 0, Math.PI * 2);
                ctx.stroke();
            }

            ctx.fillStyle = '#ffaa44';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 8;
            ctx.fillText('üêæ', mouse.x, mouse.y);
            ctx.shadowBlur = 0;
        }

        function drawGameOver() {
            const gameOverGradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, canvas.width/2);
            gameOverGradient.addColorStop(0, 'rgba(139, 0, 0, 0.8)');
            gameOverGradient.addColorStop(1, 'rgba(0, 0, 0, 0.95)');
            ctx.fillStyle = gameOverGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = APOCAT_COLORS.catOrange;
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = APOCAT_COLORS.catOrange;
            ctx.shadowBlur = 20;
            ctx.fillText('üíÄ GAME OVER üíÄ', canvas.width / 2, canvas.height / 2 - 120);

            ctx.fillStyle = APOCAT_COLORS.warningYellow;
            ctx.font = 'bold 20px Arial';
            ctx.shadowColor = APOCAT_COLORS.warningYellow;
            ctx.shadowBlur = 10;
            ctx.fillText(`${zombiesSurvived} zombies overwhelmed APOCAT!`, canvas.width / 2, canvas.height / 2 - 80);

            ctx.fillStyle = '#fff';
            ctx.font = '24px Arial';
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 5;
            ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 - 40);
            ctx.fillText(`Survived ${round - 1} rounds`, canvas.width / 2, canvas.height / 2 - 10);
            ctx.fillText(`Zombies Slayed: ${zombiesKilled}`, canvas.width / 2, canvas.height / 2 + 20);

            const accuracy = totalPaws > 0 ? Math.round((hits / totalPaws) * 100) : 0;
            ctx.fillText(`Accuracy: ${accuracy}%`, canvas.width / 2, canvas.height / 2 + 50);

            ctx.fillStyle = APOCAT_COLORS.energyGreen;
            ctx.fillRect(canvas.width / 2 - 150, canvas.height / 2 + 80, 120, 40);
            ctx.fillStyle = APOCAT_COLORS.glowBlue;
            ctx.fillRect(canvas.width / 2 + 30, canvas.height / 2 + 80, 120, 40);

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px Arial';
            ctx.fillText('üéÆ PLAY AGAIN', canvas.width / 2 - 90, canvas.height / 2 + 105);
            ctx.fillText('üèÜ LEADERBOARD', canvas.width / 2 + 90, canvas.height / 2 + 105);

            ctx.shadowBlur = 0;
        }

        function drawShop() {
            // Shop background
            const shopGradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, canvas.width/2);
            shopGradient.addColorStop(0, 'rgba(255, 170, 68, 0.2)');
            shopGradient.addColorStop(1, 'rgba(0, 0, 0, 0.9)');
            ctx.fillStyle = shopGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Title
            ctx.fillStyle = APOCAT_COLORS.warningYellow;
            ctx.font = 'bold 36px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = APOCAT_COLORS.warningYellow;
            ctx.shadowBlur = 15;
            ctx.fillText(`üõí APOCAT Shop - Round ${round}`, canvas.width / 2, 60);

            // Level completion message
            ctx.fillStyle = APOCAT_COLORS.energyGreen;
            ctx.font = 'bold 20px Arial';
            ctx.shadowBlur = 8;
            ctx.fillText(`üéâ Level ${round - 1} Complete! +1 Extra Life!`, canvas.width / 2, 100);

            // Coins display
            ctx.fillStyle = APOCAT_COLORS.warningYellow;
            ctx.font = 'bold 24px Arial';
            ctx.shadowBlur = 10;
            ctx.fillText(`üí∞ Coins: ${coins}`, canvas.width / 2, 140);

            // Upgrade grid
            const upgradeKeys = Object.keys(upgrades);
            const cols = 2;
            const rows = 2;
            const upgradeWidth = 180;
            const upgradeHeight = 120;
            const startX = (canvas.width - (cols * upgradeWidth + (cols - 1) * 20)) / 2;
            const startY = 180;

            upgradeKeys.forEach((key, index) => {
                const upgrade = upgrades[key];
                const col = index % cols;
                const row = Math.floor(index / cols);
                const x = startX + col * (upgradeWidth + 20);
                const y = startY + row * (upgradeHeight + 30);

                // Upgrade background
                const canAfford = coins >= upgrade.cost && upgrade.level < upgrade.maxLevel;
                const bgColor = canAfford ? 'rgba(0, 255, 136, 0.2)' : 'rgba(100, 100, 100, 0.2)';
                const borderColor = canAfford ? APOCAT_COLORS.energyGreen : '#666';

                ctx.fillStyle = bgColor;
                ctx.fillRect(x, y, upgradeWidth, upgradeHeight);
                ctx.strokeStyle = borderColor;
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, upgradeWidth, upgradeHeight);

                // Upgrade icon
                const icons = { biggerPaw: 'üêæ', strongerPaw: 'üí™', moreEnergy: '‚ö°', energyRegen: 'üîã' };
                ctx.fillStyle = canAfford ? APOCAT_COLORS.warningYellow : '#888';
                ctx.font = '32px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(icons[key], x + upgradeWidth/2, y + 35);

                // Upgrade name
                ctx.fillStyle = canAfford ? '#fff' : '#aaa';
                ctx.font = 'bold 14px Arial';
                ctx.fillText(upgrade.name, x + upgradeWidth/2, y + 55);

                // Level indicator
                ctx.font = '12px Arial';
                ctx.fillText(`Level ${upgrade.level}/${upgrade.maxLevel}`, x + upgradeWidth/2, y + 75);

                // Cost
                if (upgrade.level < upgrade.maxLevel) {
                    ctx.fillStyle = canAfford ? APOCAT_COLORS.warningYellow : '#ff6666';
                    ctx.font = 'bold 12px Arial';
                    ctx.fillText(`üí∞ ${upgrade.cost}`, x + upgradeWidth/2, y + 95);
                } else {
                    ctx.fillStyle = APOCAT_COLORS.energyGreen;
                    ctx.font = 'bold 12px Arial';
                    ctx.fillText('MAX LEVEL', x + upgradeWidth/2, y + 95);
                }

                // Description
                ctx.fillStyle = '#ccc';
                ctx.font = '10px Arial';
                ctx.fillText(upgrade.description, x + upgradeWidth/2, y + 110);
            });

            // Continue button
            ctx.fillStyle = APOCAT_COLORS.energyGreen;
            ctx.fillRect(canvas.width / 2 - 100, canvas.height - 80, 200, 40);
            ctx.strokeStyle = APOCAT_COLORS.energyGreen;
            ctx.lineWidth = 2;
            ctx.strokeRect(canvas.width / 2 - 100, canvas.height - 80, 200, 40);

            ctx.fillStyle = '#000';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('‚ñ∂Ô∏è CONTINUE TO NEXT LEVEL', canvas.width / 2, canvas.height - 55);

            ctx.shadowBlur = 0;
        }

        function drawScoreboard() {
            drawBackground();

            const overlayGradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, canvas.width/2);
            overlayGradient.addColorStop(0, 'rgba(26, 26, 46, 0.8)');
            overlayGradient.addColorStop(1, 'rgba(0, 0, 0, 0.9)');
            ctx.fillStyle = overlayGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = APOCAT_COLORS.catOrange;
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = APOCAT_COLORS.catOrange;
            ctx.shadowBlur = 15;
            ctx.fillText('üèÜ HIGH SCORES & TOKEN REWARDS üèÜ', canvas.width / 2, 50);
            ctx.shadowBlur = 0;

            ctx.fillStyle = '#fff';
            ctx.font = '14px Arial';
            ctx.fillText('Top Players & apoCATlypse Meow - APOCAT Token Holders', canvas.width / 2, 75);
            ctx.fillText('üéÅ Automatic APOCAT token distribution when you reach milestones!', canvas.width / 2, 95);

            // High Scores Section
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('üéÆ HIGH SCORES (Best Single Run)', canvas.width / 2, 125);

            const topScores = scoreboard.getTopScores(3);
            topScores.forEach((entry, index) => {
                const y = 150 + index * 30;
                const rankColor = index === 0 ? '#FFD700' : index === 1 ? '#C0C0C0' : index === 2 ? '#CD7F32' : '#fff';
                const rankEmoji = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : '';

                ctx.fillStyle = rankColor;
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'left';
                const playerName = entry.walletAddress === 'Anonymous' ? 'Anonymous' : `${entry.walletAddress.slice(0, 6)}...${entry.walletAddress.slice(-4)}`;
                ctx.fillText(`${rankEmoji} ${playerName}`, 100, y);

                ctx.textAlign = 'right';
                ctx.fillText(`${entry.score.toLocaleString()} pts`, 700, y);
            });

            // Token Rewards Section
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ü™ô YOUR APOCAT TOKEN REWARDS', canvas.width / 2, 280);

            // Show player's pending rewards
            const pendingTotal = rewardSystem.getTotalPending();
            const claimedTotal = rewardSystem.getTotalClaimed();

            ctx.fillStyle = '#00FF88';
            ctx.font = 'bold 14px Arial';
            ctx.fillText(`üí∞ Pending: ${pendingTotal.toFixed(3)} APOCAT | Claimed: ${claimedTotal.toFixed(3)} APOCAT`, canvas.width / 2, 305);

            const tokenRewards = [
                { milestone: 'New High Score', tokens: '1 APOCAT', status: '‚úÖ Active' },
                { milestone: 'Complete Round', tokens: '0.001 APOCAT', status: '‚úÖ Active' },
                { milestone: 'New Round Record', tokens: '0.01 APOCAT', status: '‚úÖ Active' },
                { milestone: 'Boss Defeated', tokens: '0.005 APOCAT', status: '‚úÖ Active' },
                { milestone: 'Perfect Round', tokens: '0.002 APOCAT', status: '‚úÖ Active' }
            ];

            // Collect Rewards Button (if pending rewards > 0)
            if (pendingTotal > 0) {
                ctx.fillStyle = 'rgba(255, 215, 0, 0.2)';
                ctx.fillRect(canvas.width / 2 - 100, 325, 200, 35);
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 2;
                ctx.strokeRect(canvas.width / 2 - 100, 325, 200, 35);

                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`üéÅ COLLECT ${pendingTotal.toFixed(3)} APOCAT`, canvas.width / 2, 345);
            }

            // Token rewards header
            ctx.fillStyle = '#666';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('MILESTONE', 120, 380);
            ctx.fillText('REWARD', 320, 380);
            ctx.fillText('STATUS', 520, 380);

            tokenRewards.forEach((reward, index) => {
                const y = 405 + index * 25;

                ctx.fillStyle = '#fff';
                ctx.font = '14px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(reward.milestone, 120, y);

                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 14px Arial';
                ctx.fillText(reward.tokens, 320, y);

                ctx.fillStyle = '#00FF88';
                ctx.font = '12px Arial';
                ctx.fillText(reward.status, 520, y);
            });

            // Distribution info
            ctx.fillStyle = 'rgba(255, 215, 0, 0.1)';
            ctx.fillRect(50, 480, 700, 80);
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2;
            ctx.strokeRect(50, 480, 700, 80);

            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('üí∞ COLLECT YOUR apoCATlypse Meow - APOCAT REWARDS', canvas.width / 2, 505);
            ctx.fillStyle = '#fff';
            ctx.font = '12px Arial';
            ctx.fillText('‚Ä¢ Reach milestones to unlock APOCAT tokens for collection', canvas.width / 2, 525);
            ctx.fillText('‚Ä¢ Collect when you have enough for gas fees - tokens stored safely!', canvas.width / 2, 540);

            // Back button
            ctx.fillStyle = APOCAT_COLORS.catOrange;
            ctx.fillRect(canvas.width - 120, 20, 80, 40);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('BACK', canvas.width - 80, 45);
        }

        // Mouse tracking
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
        });

        // Click handling
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (gameState === 'menu') {
                if (x >= canvas.width / 2 - 100 && x <= canvas.width / 2 + 100 &&
                    y >= canvas.height / 2 + 100 && y <= canvas.height / 2 + 145) {
                    gameState = 'playing';
                    addChatMessage('', `üéÆ ${walletAddress ? walletAddress.slice(0, 6) + '...' : 'Anonymous'} started a new game!`, true);
                    score = 0;
                    round = 1;
                    roundTimer = 30;
                    roundStartTime = 0;
                    zombies = [];
                    catFood = [];
                    particles = [];
                    pawSwipes = [];
                    currentBoss = null;
                    bossSpawned = false;
                    zombiesSurvived = 0;
                    zombiesKilled = 0;
                    totalPaws = 0;
                    hits = 0;
                    stamina = maxStamina;
                    extraLives = 0;
                    maxSurvivors = baseLives;
                    comboCount = 0;
                    comboTimer = 0;
                    zombieSpawnTimer = 0;
                    coins = 0;
                    // Reset upgrades
                    Object.keys(upgrades).forEach(key => {
                        upgrades[key].level = 0;
                        upgrades[key].cost = key === 'biggerPaw' ? 50 :
                                           key === 'strongerPaw' ? 75 :
                                           key === 'moreEnergy' ? 100 : 125;
                    });
                    applyUpgrades();
                    console.log('üéÆ Game started! Good luck, APOCAT!');
                } else if (x >= canvas.width / 2 - 100 && x <= canvas.width / 2 + 100 &&
                           y >= canvas.height / 2 + 155 && y <= canvas.height / 2 + 190) {
                    if (userAccount) {
                        walletAddress = userAccount;
                        console.log('üí∞ Wallet connected for rewards!');
                    } else {
                        connectWallet();
                    }
                } else if (x >= canvas.width / 2 - 100 && x <= canvas.width / 2 + 100 &&
                           y >= canvas.height / 2 + 200 && y <= canvas.height / 2 + 235) {
                    gameState = 'scoreboard';
                    console.log('üèÜ Opening leaderboard...');
                }
            } else if (gameState === 'playing') {
                initSoundsOnFirstClick(); // Initialize sounds on first interaction

                if (stamina < staminaCost) {
                    addAnimation('stamina_warning', x, y, { duration: 1000 });
                    console.log('üòø Not enough stamina!');
                    return;
                }

                stamina -= staminaCost;
                totalPaws++;
                let hit = false;

                // Check boss first (priority target)
                if (currentBoss) {
                    const distance = Math.sqrt(Math.pow(x - currentBoss.x, 2) + Math.pow(y - currentBoss.y, 2));
                    const hitRadius = getHitRadius();

                    if (distance < currentBoss.size / 2 + hitRadius) {
                        const damage = Math.ceil(1 * getDamageMultiplier());
                        currentBoss.health -= damage;
                        currentBoss.isHurt = true;
                        currentBoss.hurtTimer = 500;

                        const currentTime = Date.now();
                        if (currentTime - lastHitTime < 2000) {
                            comboCount++;
                            comboTimer = 3000;
                        } else {
                            comboCount = 1;
                            comboTimer = 3000;
                        }
                        lastHitTime = currentTime;

                        hits++;
                        perfectHits++;
                        missStreak = 0;
                        playSound(sounds.pawHit);

                        if (currentBoss.health <= 0) {
                            let basePoints = currentBoss.points;
                            let comboBonus = Math.floor(basePoints * (comboCount - 1) * 0.2);
                            let totalPoints = basePoints + comboBonus;

                            score += totalPoints;
                            zombiesKilled++;

                            addAnimation('combo_popup', currentBoss.x, currentBoss.y - 50, {
                                duration: 3000,
                                combo: comboCount,
                                points: totalPoints
                            });

                            addAnimation('boss_defeated', canvas.width / 2, canvas.height / 2, {
                                duration: 2000
                            });

                            createExplosion(currentBoss.x, currentBoss.y);
                            currentBoss = null;
                            console.log(`üëπ BOSS DEFEATED! +${totalPoints} points (Combo: ${comboCount}x)`);
                        } else {
                            addAnimation('damage_popup', currentBoss.x, currentBoss.y - 20, {
                                duration: 800,
                                text: `${currentBoss.health}/${currentBoss.maxHealth} HP`
                            });
                            console.log(`üëπ Hit BOSS! ${currentBoss.health}/${currentBoss.maxHealth} HP remaining`);
                        }

                        createPawSwipe(x, y);
                        hit = true;
                    }
                }

                if (!hit) {
                    for (let i = zombies.length - 1; i >= 0; i--) {
                        const zombie = zombies[i];
                        const distance = Math.sqrt(Math.pow(x - zombie.x, 2) + Math.pow(y - zombie.y, 2));
                        const hitRadius = getHitRadius();

                        if (distance < zombie.size / 2 + hitRadius) {
                        const damage = Math.ceil(1 * getDamageMultiplier());
                        zombie.health -= damage;
                        zombie.isHurt = true;
                        zombie.hurtTimer = 500;

                        const currentTime = Date.now();
                        if (currentTime - lastHitTime < 2000) {
                            comboCount++;
                            comboTimer = 3000;
                        } else {
                            comboCount = 1;
                            comboTimer = 3000;
                        }
                        lastHitTime = currentTime;

                        hits++;
                        perfectHits++;
                        missStreak = 0;
                        playSound(sounds.pawHit);

                        if (zombie.health <= 0) {
                            let basePoints = zombie.points;
                            let comboBonus = Math.floor(basePoints * (comboCount - 1) * 0.2);
                            let totalPoints = basePoints + comboBonus;

                            score += totalPoints;
                            zombiesKilled++;

                            if (comboCount >= 3) {
                                stamina = Math.min(maxStamina, stamina + 5);
                            }

                            if (zombie.type === 'bug' || zombie.type === 'bird') {
                                activateStaminaBoost(2000);
                            }

                            if (comboCount > 1) {
                                addAnimation('combo_popup', zombie.x, zombie.y - 50, {
                                    duration: 2000,
                                    combo: comboCount,
                                    points: totalPoints
                                });
                            } else {
                                addAnimation('score_popup', zombie.x, zombie.y - 30, {
                                    duration: 1500,
                                    points: totalPoints
                                });
                            }

                            createExplosion(zombie.x, zombie.y);
                            playSound(sounds.enemyDeath);
                            zombies.splice(i, 1);
                            console.log(`üêæ Defeated ${zombie.type} invader! +${totalPoints} points (Combo: ${comboCount}x)`);
                        } else {
                            addAnimation('damage_popup', zombie.x, zombie.y - 20, {
                                duration: 800,
                                text: 'HIT!'
                            });
                            console.log(`üêæ Hit ${zombie.type} invader! ${zombie.health}/${zombie.maxHealth} HP remaining`);
                        }

                            createPawSwipe(x, y);
                            hit = true;
                            break;
                        }
                    }
                }

                // Check cat food clicks
                if (!hit) {
                    for (let i = catFood.length - 1; i >= 0; i--) {
                        const food = catFood[i];
                        const distance = Math.sqrt(Math.pow(x - food.x, 2) + Math.pow(y - food.y, 2));

                        if (distance < food.size / 2 + 20) {
                            // Restore stamina MASSIVELY for boss fights
                            stamina = maxStamina; // Full restore!
                            catFood.splice(i, 1);

                            addAnimation('food_eaten', x, y, {
                                duration: 1000,
                                text: 'FULL ENERGY!'
                            });

                            createPawSwipe(x, y);
                            hit = true;
                            console.log('üçñ Ate cat food! FULL STAMINA RESTORED!');
                            break;
                        }
                    }
                }

                if (!hit) {
                    missStreak++;
                    perfectHits = 0;
                    playSound(sounds.pawMiss);

                    // Reset combo completely on miss
                    if (comboCount > 0) {
                        comboCount = 0;
                        comboTimer = 0;
                        addAnimation('combo_break', x, y, { duration: 1000 });
                    }

                    createPawSwipe(x, y);
                    console.log(`üí® Missed! Combo reset! (Miss streak: ${missStreak})`);
                }
            } else if (gameState === 'gameOver') {
                if (x >= canvas.width / 2 - 150 && x <= canvas.width / 2 - 30 &&
                    y >= canvas.height / 2 + 80 && y <= canvas.height / 2 + 120) {
                    gameState = 'playing';
                    score = 0;
                    round = 1;
                    roundTimer = 30;
                    roundStartTime = 0;
                    zombies = [];
                    catFood = [];
                    particles = [];
                    pawSwipes = [];
                    currentBoss = null;
                    bossSpawned = false;
                    zombiesSurvived = 0;
                    zombiesKilled = 0;
                    totalPaws = 0;
                    hits = 0;
                    stamina = maxStamina;
                    extraLives = 0;
                    maxSurvivors = baseLives;
                    comboCount = 0;
                    comboTimer = 0;
                    coins = 0;
                    // Reset upgrades
                    Object.keys(upgrades).forEach(key => {
                        upgrades[key].level = 0;
                        upgrades[key].cost = key === 'biggerPaw' ? 50 :
                                           key === 'strongerPaw' ? 75 :
                                           key === 'moreEnergy' ? 100 : 125;
                    });
                    applyUpgrades();
                    console.log('üéÆ Starting new game!');
                } else if (x >= canvas.width / 2 + 30 && x <= canvas.width / 2 + 150 &&
                           y >= canvas.height / 2 + 80 && y <= canvas.height / 2 + 120) {
                    gameState = 'scoreboard';
                    console.log('üèÜ Opening leaderboard...');
                }
            } else if (gameState === 'shop') {
                // Check upgrade purchases
                const upgradeKeys = Object.keys(upgrades);
                const cols = 2;
                const upgradeWidth = 180;
                const upgradeHeight = 120;
                const startX = (canvas.width - (cols * upgradeWidth + (cols - 1) * 20)) / 2;
                const startY = 180;

                upgradeKeys.forEach((key, index) => {
                    const col = index % cols;
                    const row = Math.floor(index / cols);
                    const upgradeX = startX + col * (upgradeWidth + 20);
                    const upgradeY = startY + row * (upgradeHeight + 30);

                    if (x >= upgradeX && x <= upgradeX + upgradeWidth &&
                        y >= upgradeY && y <= upgradeY + upgradeHeight) {
                        if (buyUpgrade(key)) {
                            console.log(`üõí Purchased ${upgrades[key].name}!`);
                        } else {
                            console.log(`‚ùå Cannot afford ${upgrades[key].name}`);
                        }
                    }
                });

                // Check continue button
                if (x >= canvas.width / 2 - 100 && x <= canvas.width / 2 + 100 &&
                    y >= canvas.height - 80 && y <= canvas.height - 40) {
                    // Start next round
                    gameState = 'playing';
                    roundStartTime = 0;
                    roundTimer = 30;
                    console.log(`üéØ Starting Round ${round}!`);
                }
            } else if (gameState === 'scoreboard') {
                // Back to menu button
                if (x >= canvas.width - 120 && x <= canvas.width - 40 &&
                    y >= 20 && y <= 60) {
                    gameState = 'menu';
                    console.log('üîÑ Returning to menu...');
                }

                // Collect rewards button
                const pendingTotal = rewardSystem.getTotalPending();
                if (pendingTotal > 0 &&
                    x >= canvas.width / 2 - 100 && x <= canvas.width / 2 + 100 &&
                    y >= 325 && y <= 360) {

                    if (walletAddress) {
                        // Check bot status and trigger collection
                        rewardSystem.collectRewards(walletAddress, pendingTotal);
                    } else {
                        addChatMessage('', '‚ö†Ô∏è Please connect your wallet to collect APOCAT tokens!', true);
                        console.log('‚ö†Ô∏è Wallet not connected for token collection');
                    }
                }
            }
        });

        console.log('üéÆ APOCAT Game Initialized!');
        gameLoop();
    </script>
</body>
</html>
